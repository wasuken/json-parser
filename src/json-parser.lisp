(in-package #:json-parser)

(defun array-check (lst str)
  (if (>= (length lst) 2)
	  (and (stringp (nth 1 lst))
		   (string= str (nth 1 lst))
		   (array-check (nthcdr 2 lst) str))
	  t))

(defun array-listp (lst)
  (and (listp lst)
	   (= (count-if #'(lambda (x) (and (stringp x) (string= x ","))) lst)
		  (1- (- (length lst)
				 (count-if #'(lambda (x) (and (stringp x) (string= x ","))) lst))))
	   (if (stringp (car (reverse lst)))
		   (not (string= (car (reverse lst)) ","))
		   t)
	   (array-check lst ",")))

(defun array-to-lst (array)
  (mapcar #'(lambda (x) (cond ((array-listp x)
							   (array-to-lst x))
							  ((listp x)
							   (braces-to-lst x))
							  (t (varies-with-type (string-trim '(#\Space) x)))))
		  (remove-if #'(lambda (x) (and (stringp x) (string= "," x))) array)))

(defun braces-to-lst (str-lst-in-braces)
  (cond ((null str-lst-in-braces)
		 nil)
		((listp (car str-lst-in-braces))
		 (cons (braces-to-lst (car str-lst-in-braces))
			   (braces-to-lst (cdr str-lst-in-braces))))
		((string= (car str-lst-in-braces) "{")
		 (list (braces-to-lst (cdr str-lst-in-braces))))
		((string= (car str-lst-in-braces) "}")
		 nil)
		((string= (car str-lst-in-braces) "[")
		 (list (braces-to-lst (cdr str-lst-in-braces))))
		((string= (car str-lst-in-braces) "]")
		 nil)
		(t (cons (car str-lst-in-braces)
				 (braces-to-lst (cdr str-lst-in-braces))))))

(defun core-parse (str)
  (let ((dq-flg nil)
		(temp-str "")
		(result '()))
	(loop for c across str
	   do (cond ((and dq-flg (eql #\" c))
				 (push (concatenate 'string "\"" temp-str "\"") result)
				 (setf temp-str "")
				 (setf dq-flg (not dq-flg)))
				;; {}
				((and (not dq-flg) (eql #\{ c))
				 (push temp-str result)
				 (setf temp-str "")
				 (push (concatenate 'string `(,c)) result))
				((and (not dq-flg) (eql #\} c))
				 (push temp-str result)
				 (setf temp-str "")
				 (push (concatenate 'string `(,c)) result))
				;; []
				((and (not dq-flg) (eql #\[ c))
				 (push temp-str result)
				 (setf temp-str "")
				 (push (concatenate 'string `(,c)) result))
				((and (not dq-flg) (eql #\] c))
				 (push temp-str result)
				 (setf temp-str "")
				 (push (concatenate 'string `(,c)) result))
				((eql #\" c)
				 (push temp-str result)
				 (setf temp-str "")
				 (setf dq-flg (not dq-flg)))
				((and (not dq-flg) (eql #\: c))
				 (push temp-str result)
				 (setf temp-str "")
				 (push (concatenate 'string `(,c)) result))
				((and (not dq-flg) (eql #\, c))
				 (push temp-str result)
				 (setf temp-str "")
				 (push (concatenate 'string `(,c)) result))
				(t (setf temp-str (concatenate 'string temp-str `(,c))))))
	(unless (string= temp-str "")
	  (push temp-str result))
	(remove-if #'(lambda (x) (string= (string-trim '(#\Space) x) ""))
			   (reverse result))))

(defun str-list-split (piv-str lst)
  (let ((temp-lst '())
		(result '()))
	(loop for i in lst
	   do (cond ((and (stringp i) (string= i piv-str))
				 (push (reverse temp-lst) result)
				 (setf temp-lst '()))
				(t (push i temp-lst))))
	(when result
	  (push (reverse temp-lst) result))
	(reverse result)))

(defun parse-method (tree)
  (cond ((null tree) nil)
		((listp (car tree))
		 (cons (parse-method (car tree))
			   (parse-method (cdr tree))))
		(t (cons (str-list-split "," (car tree))
				 (parse-method (cdr tree))))))

(defun varies-with-type (str &optional (is-right nil))
  (cond ((ppcre:scan-to-strings "\".*?\"" str)
		 (ppcre:register-groups-bind (n)
			 ("\"(.*?)\"" str)
		   n))
		((string= (string-downcase str) "true") t)
		((string= (string-downcase str) "false") nil)
		((and is-right (string= (string-downcase str) "null")) nil)
		((ppcre:scan-to-strings "^[0-9][0-9|\.]+$" str) (parse-float:parse-float str))
		((ppcre:scan-to-strings "^[0-9]+$" str) (parse-integer str))
		(t str)))

(defun json-core-parse (lst)
  (cond ((null lst) nil)
		((or (null (car lst)) (listp (car lst)))
		 (error "left node can't braces."))
		((array-listp lst)
		 (array-to-lst lst))
		(t
		 (if (stringp (car lst))
			 (let ((left (car lst))
				   (colon (nth 1 lst))
				   (right (nth 2 lst)))
			   (when (and (not (array-listp right))
			   		   (or (ppcre:scan-to-strings "," left)
			   			   (ppcre:scan-to-strings "," colon)))
			     (error "syntax error."))
			   (when (listp left)
				 (error "the left element can't be a brace."))
			   `( ,(intern (varies-with-type (string-trim '(#\Space) left)) :keyword)
				   ,(if (listp right)
						(json-core-parse right)
						(if (array-listp right)
							(array-to-lst right)
							(varies-with-type (string-trim '(#\Space) right) t)))
				   ,@(if (and (stringp (nth 3 lst)) (string= (nth 3 lst) ","))
						 (json-core-parse (nthcdr 4 lst)))))
			 (json-core-parse (car lst))))
		)
  )

(defun braces-check (lst)
  (let ((lbrace-cnt (count-if #'(lambda (x) (ppcre:scan-to-strings "{" x)) lst))
		(rbrace-cnt (count-if #'(lambda (x) (ppcre:scan-to-strings "}" x)) lst))
		(lbracket-cnt (count-if #'(lambda (x) (ppcre:scan-to-strings "\\[" x)) lst))
		(rbracket-cnt (count-if #'(lambda (x) (ppcre:scan-to-strings "\\]" x)) lst))
		(first (car lst))
		(last (car (reverse lst))))
	(unless (= lbrace-cnt rbrace-cnt)
	  (error "mismatched number of braces."))
	(unless (= rbracket-cnt lbracket-cnt)
	  (error "mismatched number of brackets."))
	(when (= lbrace-cnt rbrace-cnt lbracket-cnt rbracket-cnt 0)
	  (error "no braces and brackets."))
	(if (>= (length lst) 2)
		(unless (and (ppcre:scan-to-strings "\\[|{" first)
					 (ppcre:scan-to-strings "\\]|}" last))
		  (error "The beginning and end of the string are not expected strings")))
	))

(defun parse (str)
  (let ((disassembly-lst (core-parse str)))
	(braces-check disassembly-lst)
	(json-core-parse (car (braces-to-lst disassembly-lst)))))
