(in-package #:json-parser)

(defun braces-to-lst (str-lst-in-braces)
  (cond ((string= (car str-lst-in-braces) "{")
		 (list (braces-to-lst (cdr str-lst-in-braces))))
		((string= (car str-lst-in-braces) "}")
		 nil)
		((listp (car str-lst-in-braces))
		 (cons (braces-to-lst (car str-lst-in-braces))
			   (braces-to-lst (cdr str-lst-in-braces))))
		(t (cons (car str-lst-in-braces)
				 (braces-to-lst (cdr str-lst-in-braces))))))

(defun core-parse (str)
  (let ((dq-flg nil)
		(temp-str "")
		(result '()))
	(loop for c across str
	   do (cond ((and dq-flg (eql #\" c))
				 (push (concatenate 'string "\"" temp-str "\"") result)
				 (setf temp-str "")
				 (setf dq-flg (not dq-flg)))
				((and (not dq-flg) (eql #\{ c))
				 (push temp-str result)
				 (setf temp-str "")
				 (push (concatenate 'string `(,c)) result))
				((and (not dq-flg) (eql #\} c))
				 (push temp-str result)
				 (setf temp-str "")
				 (push (concatenate 'string `(,c)) result))
				((eql #\" c)
				 (push temp-str result)
				 (setf temp-str "")
				 (setf dq-flg (not dq-flg)))
				((and (not dq-flg) (eql #\: c))
				 (push temp-str result)
				 (setf temp-str "")
				 (push (concatenate 'string `(,c)) result))
				((and (not dq-flg) (eql #\, c))
				 (push temp-str result)
				 (setf temp-str "")
				 (push (concatenate 'string `(,c)) result))
				(t (setf temp-str (concatenate 'string temp-str `(,c))))))
	(unless (string= temp-str "")
	  (push temp-str result))
	(remove-if #'(lambda (x) (string= (string-trim '(#\Space) x) ""))
			   (reverse result))))

(defun str-list-split (piv-str lst)
  (let ((temp-lst '())
		(result '()))
	(loop for i in lst
	   do (cond ((and (stringp i) (string= i piv-str))
				 (push (reverse temp-lst) result)
				 (setf temp-lst '()))
				(t (push i temp-lst))))
	(when result
	  (push (reverse temp-lst) result))
	(reverse result)))

(defun parse-method (tree)
  (cond ((null tree) nil)
		((listp (car tree))
		 (cons (parse-method (car tree))
			   (parse-method (cdr tree))))
		(t (cons (str-list-split "," (car tree))
				 (parse-method (cdr tree))))))

(defun varies-with-type (str)
  (cond ((ppcre:scan-to-strings "\".*?\"" str)
		 (ppcre:register-groups-bind (n)
			 ("\"(.*?)\"" str)
			 n))
		(t (parse-integer str))))

(defun json-core-parse (lst)
  (if (stringp (car lst))
	  (let ((left (car lst))
			(colon (nth 1 lst))
			(right (nth 2 lst)))
		`( ,(intern (varies-with-type left) :keyword)
			,(if (listp right)
				 (json-core-parse right)
				 (varies-with-type right))
			,@(if (and (stringp (nth 3 lst)) (string= (nth 3 lst) ","))
				  (json-core-parse (nthcdr 4 lst)))))
	  (json-core-parse (car lst))))

(defun parse (str)
  (json-core-parse (braces-to-lst (core-parse str))))
